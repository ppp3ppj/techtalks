<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<style>
    .fragment.blur {
        filter: blur(5px);
    }

    .fragment.blur.visible {
        filter: none;
    }
</style>

<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h2>Design pattern 101</h2>
            </section>
            <section style="text-align: Left;">
                <h3>
                    Programing Paradigm
                </h3>

                <p class="fragment custom blur" style="color:red">Imperative - Procedural, OOP</p>
                <p class="fragment custom blur" style="color:green">Declarative - Functional, Reactive, Logic</p>
                <p class="fragment custom blur" style="color:gray">Concurrent - Acto</p>
                <p class="fragment custom blur" style="color:gray">Meta - Template, Reflective</p>
                <p class="fragment custom blur" style="color:gray">...</p>
            </section>
            <section>
                <h3>
                    OOP Concept
                </h3>
                <p class="fragment" data-fragment-index="1">Object</p>
                <p class="fragment" data-fragment-index="1">Class</p>
                <p class="fragment" data-fragment-index="2">Inheritance</p>
                <p class="fragment" data-fragment-index="3">Encapsulation</p>
                <p class="fragment" data-fragment-index="4">Abstraction</p>
                <p class="fragment" data-fragment-index="5">Polymorphism</p>
            </section>
            <section>
                <section data-background-gradient="linear-gradient(to bottom, #283b95, #17b2c3)">
                    <h3>
                        SOLID Principles
                    </h3>
                    "Make object-oriented designs more understandable, flexible, and maintainable."
                </section>

                <section data-background-color="aquamarine">
                    <h3>
                        Single-responsibility principle
                    </h3>
                    "There should never be more than one reason for a class to change.
                    In other words, every class should have only one responsibility."
                </section>

            <section>
                <h2>What is SRP?</h2>
                <p>SRP states that a class should have only one reason to change.</p>
                <p>Each class should handle a single, specific responsibility.</p>
            </section>

            <section>
                <h2>Bad Example: Violating SRP</h2>
                <pre><code class="javascript">/**
 * Class representing a BadMemberManager.
 */
class BadMemberManager {
    constructor() {
        this.members = [];
    }

    addMember(name, age, role) {
        const member = { name, age, role };
        this.members.push(member);
    }

    getMembers() {
        return this.members;
    }

    findMember(name) {
        return this.members.find(member => member.name === name);
    }

    async printMembers() {
        if (this.members.length === 0) {
            await Bun.write(Bun.stdout, 'No members found.');
            return;
        }

        await Bun.write(Bun.stdout, 'Member List:\n');
        this.members.forEach(async member => {
            await Bun.write(Bun.stdout, `Name: ${member.name}, Age: ${member.age}, Role: ${member.role}`);
        });
    }
}</code></pre>
            </section>

            <section>
                <h2>Why is This a Problem?</h2>
                <ul>
                    <li><strong>Multiple Responsibilities:</strong> The class manages data and handles output.</li>
                    <li><strong>Complex Maintenance:</strong> Changes to printing logic require modifying this class.</li>
                    <li><strong>Testing Challenges:</strong> I/O operations make the class harder to unit test.</li>
                </ul>
            </section>

          <section>
                <h2>How to Fix This</h2>
                <p>Separate the concerns into different classes:</p>
                <ul>
                    <li><strong>MemberManager:</strong> Handles data management (adding, finding members).</li>
                    <li><strong>MemberPrinter:</strong> Handles printing or displaying member details.</li>
                </ul>
            </section>

            <section>
                <h2>Refactored Example</h2>
                <pre><code class="javascript">
// Class handling member data
class MemberManager {
    constructor() {
        this.members = [];
    }

    addMember(name, age, role) {
        const member = { name, age, role };
        this.members.push(member);
    }

    getMembers() {
        return this.members;
    }

    findMember(name) {
        return this.members.find(member => member.name === name);
    }
}

// Class handling output
class MemberPrinter {
    async printMembers(members) {
        if (members.length === 0) {
            await Bun.write(Bun.stdout, 'No members found.');
            return;
        }

        await Bun.write(Bun.stdout, 'Member List:\n');
        for (const member of members) {
            await Bun.write(Bun.stdout, `Name: ${member.name}, Age: ${member.age}, Role: ${member.role}\n`);
        }
    }
}
                </code></pre>
            </section>

            <!-- Slide 7: Conclusion -->
            <section>
                <h2>Conclusion</h2>
                <p>Applying SRP makes your code:</p>
                <ul>
                    <li>More maintainable</li>
                    <li>Easier to test</li>
                    <li>Less coupled</li>
                </ul>
            </section>

                <section data-background-color="rgb(70, 70, 255)">
                    <h3>
                        Open-closed principle
                    </h3>
                    "Software entities ... should be open for extension, but closed for modification." "
                </section>

                <section data-background-color="rgb(235, 131, 23)">
                    <h3>
                        Liskov substitution principle
                    </h3>
                    "Functions that use pointers or references to base classes must be able to use objects of derived
                    classes without knowing it."
                </section>
                <section data-background-color="rgb(243, 198, 35)">
                    <h3>
                        Interface segregation principle
                    </h3>
                    "Clients should not be forced to depend upon interfaces that they do not use."
                </section>
                <section data-background-color="rgb(244, 246, 255)">
                    <h3>
                        Dependency inversion principle
                    </h3>
                    "Depend upon abstractions, [not] concretes."
                </section>

            </section>

            <section>
                <section data-background-gradient="linear-gradient(to bottom, #283b95, #17b2c3)">
                    <h3>
                        Design Patterns
                    </h3>
                    "General repeatable solution to a commonly occurring problem in software design"
                </section>

                <section>
                    <h3>
 Creational patterns
                    </h3>
 are ones that create objects, rather than having to instantiate objects directly. This gives the program more flexibility in deciding which objects need to be created for a given case.
                </section>
                <section>
                    Factory Method, Abstract Factory, Builder, Prototype, Singleton
                </section>

                <section>
                    <h3>
 Structural patterns
                    </h3>
                    concern class and object composition. They use inheritance to compose interfaces and define ways to compose objects to obtain new functionality.
                </section>

                <section>
                    Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy
                </section>

                <section>
                    <h3>
 Behavioral patterns
                    </h3>
                     specifically concerned with communication between objects
                </section>

                <section>
                    Iterator, Mediator, Observer, Visitor, Strategy, State, Command, Chain of Responsibility, Memento, Template Method, Interpreter
                </section>

                <section>
                    <h3>
                        1. The Factory Pattern: Making Potion Brewers
                    </h3>
Scenario: In our magical world, we have different kinds of potion brewers: some brew healing potions, others brew invisibility potions. But instead of hardcoding how each potion is made, we'll use a Factory Pattern to dynamically create the right brewer!
                </section>
                <section>
                    <h3>
                        2. The Strategy Pattern: Choosing Brewing Techniques
                    </h3>
Scenario: Cats have different brewing styles! Some are patient and slow, while others boil the ingredients rapidly. We use the Strategy Pattern to allow our cats to choose their brewing technique based on the situation.
                </section>
                <section>
                    <h3>
                        3. The Builder Pattern: Crafting Potions with Ingredients
                    </h3>
Scenario: Potions aren't made from a single ingredient. Cats have a list of magical ingredients, and they want to mix and match them to create their perfect potion! The Builder Pattern lets us construct potions step-by-step.
                </section>
                <section>
                    <h3>
                        4. The Composite Pattern: Managing Potion Collections
                    </h3>
Scenario: Our cats don't just brew one potionâ€”they need to manage a collection of potions. The Composite Pattern lets us group potions together and treat individual potions and collections uniformly.
                </section>

                <section>
                    <h2>
                        Putting It All Together:
                    </h2>
                    <h3>
                        Cats Crafting Potions
                    </h3>
                </section>
                <section>
                    Factory Pattern creates potion brewers.
Strategy Pattern decides how to brew potions (slow or fast).
Builder Pattern allows adding magical ingredients.
Composite Pattern lets cats brew multiple potions as a collection.
                </section>

            </section>


            <section>
                <section data-background-gradient="linear-gradient(to bottom, #283b95, #17b2c3)">
                    <h3>
                            Negative space programming
                    </h3>
                    "concept that embraces the art of defining a program by what it should not do, rather than what it should."
                </section>
            </section>

            <section>
                <h3>
                    Summary
                </h3>
            </section>

            <section>
                <h3>
                    QA
                </h3>
            </section>

            <section>
                <h1>
Homework
                </h1>
                <h3>
                    Implement a design pattern only one design pattern do you like and write test cases for the desingn pattern you have implemented.
                </h3>
            </section>


            <section>
                <h3>
                    exit(0)
                </h3>
            </section>
        </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            hash: true,

            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
        });
    </script>
</body>

</html>
