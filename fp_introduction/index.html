<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Functional 101</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/simple.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<style>
    .fragment.blur {
        filter: blur(5px);
    }

    .fragment.blur.visible {
        filter: none;
    }
</style>

<body>
    <div class="reveal">
        <div class="slides">
            <!-- Slide 1: Title -->
            <section>
                <h1>Functional 101</h1>
                <h3>"More Than Just Functions"</h3>
            </section>

            <section>
                <h2>Disclaimer</h2>
                <p>This presentation is your friendly introduction to the basic mindset of Functional Programming (FP). üå±</p>
                <p>We‚Äôre keeping it light, fun, and simple‚Äîno deep dives (yet). üòÑ</p>
                <p>So, sit back, relax, and let‚Äôs get those FP vibes started! üßò‚Äç‚ôÇÔ∏è</p>
            </section>

            <section style="text-align: Left;">
                <h3>
                    Programing Paradigm
                </h3>

                <p class="fragment custom blur" style="color:red">Imperative - Procedural, OOP</p>
                <p class="fragment custom blur" style="color:green">Declarative - Functional, Reactive, Logic</p>
                <p class="fragment custom blur" style="color:gray">Concurrent - Acto</p>
                <p class="fragment custom blur" style="color:gray">Meta - Template, Reflective</p>
                <p class="fragment custom blur" style="color:gray">...</p>
            </section>

        <section>
         <h2>The Awesome Family of Functional Languages</h2>
          <p>
            <strong>ML üß†:</strong> Static typing ‚Äì It knows your types before you do! üîí
          </p>
          <p>
            <strong>Lisp üçï:</strong> Dynamic typing ‚Äì It figures it out as it goes! üîÑ
          </p>
        </section>

            <section>
                <img src="image/fp_lang_list.png"
                    alt="fp lang list" style="width: 1200px; margin-bottom: 20px;" />
            </section>

      <section>
            <h2>What is Functional Programming?</h2>
            <ul>
                <li><strong>Functional Programming (FP)</strong> is a programming paradigm that treats computation as the evaluation of mathematical functions.</li>
                <li>It avoids changing-state and mutable data.</li>
                <li>Emphasizes the use of <strong>pure functions</strong> that return the same output for the same input.</li>
                <li>Popular for <strong>concurrency, parallelism, and distributed systems</strong>.</li>
            </ul>
        </section>

      <section>
        <h2>We are Focus on <em>What</em> > <em>How</em></h2>
        <ul>
          <li><strong>Describe</strong> the result, not the steps to achieve it.</li>
          <li>Use <strong>declarative</strong> logic instead of imperative instructions.</li>
          <li>Avoid manual iteration and state manipulation.</li>
          <li>Compose transformations instead of writing explicit loops.</li>
          <li>Code becomes <strong>more readable, maintainable, and predictable.</strong></li>
        </ul>
      </section>

      <section>
          <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/OCaml_Logo.svg/525px-OCaml_Logo.svg.png"
              alt="fp lang list" style="width: 1200px; margin-bottom: 20px;" />
      </section>

      <section>
        <h2>What is OCaml?</h2>
        <ul>
          <li><strong>OCaml</strong> is a functional, imperative, and object-oriented programming language.</li>
          <li>Developed by INRIA, it is known for its <strong>strong static typing</strong> and <strong>type inference</strong>.</li>
          <li>Popular for <strong>compilers, theorem proving, and finance</strong> applications.</li>
          <li>Features an expressive syntax with powerful pattern matching.</li>
          <li>Uses the <strong>Garbage Collector (GC)</strong> for memory management.</li>
        </ul>
      </section>

      <section>
        <h2>üöß OOP with Mutable List (C#)</h2>
        <pre><code class="language-csharp" data-trim data-noescape>
        var numbers = new List&lt;int&gt { 1, 2, 3, 4 };

        numbers.Add(5);

        Console.WriteLine("Numbers: " + string.Join(", ", numbers));
        </code></pre>
        <p>üõë List is mutable. Data can change freely.</p>
        <p>Output: <code>Numbers: 1, 2, 3, 4, 5</code></p>
      </section>

      <section>
        <h2>‚ú® FP with Immutable List (OCaml)</h2>
        <pre><code class="language-ocaml" data-trim data-noescape>
let numbers = [1; 2; 3; 4];;

let updated_numbers = numbers @ [5];;

List.iter (fun x -> Printf.printf "%d " x) updated_numbers;;
        </code></pre>
        <p>üöÄ Lists are immutable. You create a new list instead.</p>
        <p>Output: <code>1 2 3 4 5</code></p>
      </section>


<section>
          <h2>Currying?</h2>
          <pre><code>let add x y = x + y</code></pre>
          <p><strong>Curried Function:</strong></p>
          <pre><code>let add x = fun y -> x + y</code></pre>
          <h4>Code Example:</h4>
          <pre><code data-trim data-noescape>
let add x = fun y -> x + y
let add2 = add 2
let result = add2 3  (* result = 5 *)
          </code></pre>
        </section>


<section>
          <h2>Partial Application?</h2>
          <pre><code>let add x y = x + y</code></pre>
          <pre><code>let add5 = add 5</code></pre>
          <h4>Code Example:</h4>
          <pre><code data-trim data-noescape>
let add x y = x + y
let add5 = add 5
let result = add5 3  (* result = 8 *)
          </code></pre>
        </section>

<section>
  <h2>Function Composition?</h2>
  <p>
    (f ‚àò g)(x) = f(g(x)) 
  </p>
  <pre><code data-trim data-noescape>
let add2 x = x + 2
let multiply3 x = x * 3
  </code></pre>
  <h4>Composing them:</h4>
  <pre><code data-trim data-noescape>
let compose f g x = f (g x)
let f = compose add2 multiply3
  </code></pre>
</section>

<section>
  <h4>Code Example:</h4>
  <pre><code data-trim data-noescape>
let add2 x = x + 2
let multiply3 x = x * 3
let compose f g x = f (g x)
let f = compose add2 multiply3
let result = f 4  (* result = 14 *)
(*
    let f x = x
            |&gt  multiply3
            |&gt add2;;
                        *)
(* f 4;; *)
  </code></pre>
  <h4>How it works:</h4>
  <ul>
    <li><code>multiply3 4 = 12</code></li>
    <li><code>add2 12 = 14</code></li>
  </ul>
  <h4>Final Result:</h4>
  <p><code>f(4) = 14</code></p>
</section>

 <section>
        <h2>Lazy Evaluation in Haskell</h2>
        <pre><code>nums = [1..]

main = print (take 5 nums)</code></pre>
        <p>Output: <code>[1, 2, 3, 4, 5]</code></p>
      </section>

            <section>
                <h2>Algebraic Data Type (ADT) in OCaml</h2>
                <pre><code class="language-ocaml" data-trim data-noescape>
type shape =
  | Circle of float
  | Rectangle of float * float
  | Triangle of { base : float; height : float }

let area s =
  match s with
  | Circle r -> 3.14159 *. r *. r
  | Rectangle (w, h) -> w *. h
  | Triangle t -> 0.5 *. t.base *. t.height

let () =
  let circle = Circle 5.0 in
  let rectangle = Rectangle (4.0, 6.0) in
  let triangle = Triangle { base = 8.0; height = 5.0 } in

  Printf.printf "The area of the circle is: %.2f\n" (area circle);
  Printf.printf "The area of the rectangle is: %.2f\n" (area rectangle);
  Printf.printf "The area of the triangle is: %.2f\n" (area triangle)
                </code></pre>
            </section>

            <section>
                <h1>Monad!!!</h1>
            </section>

            <section>
                <img src="https://miro.medium.com/v2/resize:fit:4800/format:webp/1*HiqeaDuQxlpANkfPJieuVA.jpeg"
                    alt="Monad meme" style="width: 650px; margin-bottom: 20px;" />
            </section>

            <section>
                <img src="http://www.quickmeme.com/img/44/44b0bd758f8ee5c81362923f0d5c8e017c9ddf623925e60c29a4c015b89fbb45.jpg"
                    alt="Monad meme" style="width: 800px; margin-bottom: 20px;" />
            </section>

            <section>
                <img src="https://images.ctfassets.net/cnu0m8re1exe/2X2fRTnvMBP8QhjcWwjlSa/cd278daf53ceffa934b78c8ed23d66a0/shutterstock_1719135910__1_.png"
                    alt="schrodingers cat in side the box" style="width: 700px; margin-bottom: 20px;" />
            </section>

            <!-- Slide 2: Monad in OCaml -->
            <section>
                <h2>Monad in OCaml</h2>
                <p>Monads in OCaml encapsulate computations with context, such as handling errors without exceptions.</p>
                <pre><code class="language-ocaml" data-trim data-noescape>
(* Safe division using Option Monad *)
let safe_divide x y =
  if y = 0 then None else Some (x / y)

(* Monad bind function *)
let bind opt f =
  match opt with
  | None -> None
  | Some value -> f value

let () =
  let result = bind (safe_divide 10 2) (fun x ->
                safe_divide x 0) in
  match result with
  | None -> print_endline "Error: Division by zero!"
  | Some value -> print_endline (string_of_int value)
(* Output: Error: Division by zero! *)
                </code></pre>
            </section>

            <!-- Slide 8: Practical Benefits -->
            <section>
                <h2>Why Should You Care?</h2>
                <ul>
                    <li>Write less: few bug.üí§</li>
                    <li>Easier testing: Pure functions don‚Äôt lie. üïµÔ∏è‚Äç‚ôÇÔ∏è</li>
                    <li>Concurrency: No shared state = no headaches. üß†</li>
                </ul>
            </section>
            <!-- Slide 9: Closing & Resources -->
            <section>
                  <h3>Summary:</h3>
                  <img width="400" src="image/oo_fp_meme_ns.jpg" />
                  <blockquote>
                    <strong>"After learning FP, OOP just feels like unnecessary pain." üò≠</strong>
                  </blockquote>
            </section>

            <section>
                <h2>
                   Q/A |> Exit(0) |> Next section:
                </h2>
                <ul>
                  <li>Elixir fault tolerance</li>
                  <li>[Go] Composition over inheritance</li>
                </ul> 
            </section>
        </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            hash: true,

            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
        });
    </script>
</body>

</html>
