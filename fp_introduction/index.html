<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Functional programing vs OOP</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <!-- Slide 1: Title -->
            <section>
                <h1>OOP Meets Functional Programming</h1>
                <h3>"When Objects and Functions Become Friends"</h3>
            </section>

            <!-- Slide 2: Why We‚Äôre Here -->
            <section>
                <h2>Why Are We Here?</h2>
                <ul>
                    <li>Because our code has more bugs than features üêõ</li>
                    <li>Because mutating state feels like black magic üé©</li>
                    <li>Because Functional Programming sounds fancy üíÖ</li>
                </ul>
            </section>


            <!-- Slide 3: OOP vs. FP (Funny Table) -->
            <section>
                <h2>OOP vs. FP: A Showdown</h2>
                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>OOP</th>
                            <th>FP</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>State Management</td>
                            <td>Everything changes! Chaos reigns! üò±</td>
                            <td>Immutable. Chill vibes. üßò‚Äç‚ôÇÔ∏è</td>
                        </tr>
                        <tr>
                            <td>Focus</td>
                            <td>Objects = ‚ÄúI own everything‚Äù üè¢</td>
                            <td>Functions = ‚ÄúI transform everything‚Äù üîÑ</td>
                        </tr>
                        <tr>
                            <td>Side Effects</td>
                            <td>"What happens in methods... doesn‚Äôt stay there." üí•</td>
                            <td>"No surprises. Ever." üéØ</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Slide 4: OOP Analogy -->
            <section>
                <h2>OOP Is Like a Restaurant</h2>
                <p>You have:</p>
                <ul>
                    <li>A **Chef** (Object) who <em>knows everything</em>.</li>
                    <li>A kitchen full of ingredients (state) üçÖü•©.</li>
                    <li>Sometimes, the chef burns the food (side effects) üî•.</li>
                </ul>
                <p>Functional Programming is like... A fast-food joint: precise, consistent, no surprises üçî.</p>
            </section>

            <!-- Slide 5: Core Concepts -->
            <section>
                <h2>Functional Programming 101</h2>
                <ul>
                    <li><strong>Immutability</strong>: "Hands off my data!" üõë</li>
                    <li><strong>Pure Functions</strong>: "What you give is what you get." üéÅ</li>
                    <li><strong>Higher-Order Functions</strong>: "Functions that love other functions." üíû</li>
                </ul>
                <p>FP is basically: <em>Data in, data out, no drama!</em></p>
            </section>

            <!-- Slide 6: Code Example -->
            <section>
                <h1>OOP vs FP</h1>
                <p>Let‚Äôs compare Object-Oriented Programming and Functional Programming.</p>
            </section>

            <section>
                <h2>Object-Oriented Programming</h2>
                <pre><code class="language-csharp">
class Chef
{
    public string MakePizza(string toppings)
    {
        return $"Pizza with {toppings}";
    }
}

class Program
{
    static void Main(string[] args)
    {
        Chef chef = new Chef();
        Console.WriteLine(chef.MakePizza("cheese"));
    }
}
                </code></pre>
            </section>

            <!-- Slide 3: FP -->
            <section>
                <h2>Functional Programming</h2>
                <pre><code class="language-ocaml">
let make_pizza toppings =
  "Pizza with " ^ toppings

let () =
  print_endline (make_pizza "cheese")
                </code></pre>
            </section>

            <section>
                <h1>Monad in OCaml vs Error Handling in C#</h1>
                <p>Two approaches to handling errors and computation contexts effectively.</p>
            </section>

            <!-- Slide 2: Monad in OCaml -->
            <section>
                <h2>Monad in OCaml</h2>
                <p>Monads in OCaml encapsulate computations with context, such as handling errors without exceptions.</p>
                <pre><code class="language-ocaml">
(* Safe division using Option Monad *)
let safe_divide x y =
  if y = 0 then None else Some (x / y)

(* Monad bind function *)
let bind opt f =
  match opt with
  | None -> None
  | Some value -> f value

let () =
  let result = bind (safe_divide 10 2) (fun x ->
                safe_divide x 0) in
  match result with
  | None -> print_endline "Error: Division by zero!"
  | Some value -> print_endline (string_of_int value)
(* Output: Error: Division by zero! *)
                </code></pre>
            </section>

            <!-- Slide 3: Error Handling in C# -->
            <section>
                <h2>Error Handling in C#</h2>
                <p>In C#, exceptions provide a structured way to handle errors in a program.</p>
                <pre><code class="language-csharp">
using System;

class Program
{
    static double SafeDivide(double x, double y)
    {
        if (y == 0)
            throw new DivideByZeroException("Cannot divide by zero");
        return x / y;
    }

    static void Main()
    {
        try
        {
            double result = SafeDivide(10, 2);
            result = SafeDivide(result, 0); // Throws exception
            Console.WriteLine(result);
        }
        catch (DivideByZeroException e)
        {
            Console.WriteLine($"Error: {e.Message}");
        }
    }
}
// Output: Error: Cannot divide by zero
                </code></pre>
            </section>


         <section>
            <h2>Error Handling in C#</h2>
            <p>Using <strong>Option&lt;T&gt;</strong> type to handle errors without exceptions.</p>
        </section>

        <section>
            <h2>Problem with Exceptions</h2>
            <p>Using exceptions for control flow:</p>
            <pre><code class="language-csharp">using System;

class Program
{
    static double SafeDivide(double x, double y)
    {
        if (y == 0)
            throw new DivideByZeroException("Cannot divide by zero");
        return x / y;
    }

    static void Main()
    {
        try
        {
            double result = SafeDivide(10, 2);
            result = SafeDivide(result, 0); // Throws exception
            Console.WriteLine(result);
        }
        catch (DivideByZeroException e)
        {
            Console.WriteLine($"Error: {e.Message}");
        }
    }
}</code></pre>
            <p><strong>Issues:</strong> Exception handling interrupts flow, and testing is harder.</p>
        </section>

        <section>
            <h2>Introducing Option&lt;T&gt;</h2>
            <p>A functional programming approach to handle errors gracefully.</p>
            <pre><code>public class Option<T>
{
    private readonly T _value;
    public bool IsSome { get; }
    public bool IsNone => !IsSome;

    private Option(T value, bool isSome)
    {
        _value = value;
        IsSome = isSome;
    }

    public static Option<T> Some(T value) => new Option<T>(value, true);
    public static Option<T> None() => new Option<T>(default, false);

    public T UnwrapOr(T defaultValue) => IsSome ? _value : defaultValue;
    public T UnwrapOrThrow(string errorMessage)
    {
        if (IsSome) return _value;
        throw new InvalidOperationException(errorMessage);
    }
}</code></pre>
        </section>

        <section>
            <h2>Safe Division with Option&lt;T&gt;</h2>
            <pre><code class="csharp">static Option<double> SafeDivide(double x, double y)
{
    if (y == 0)
        return Option<double>.None(); // Return None when division by zero
    return Option<double>.Some(x / y);
}

static void Main()
{
    var result1 = SafeDivide(10, 2); // Valid division
    var result2 = SafeDivide(result1.UnwrapOr(0), 0); // Invalid division, returns None

    if (result2.IsSome)
    {
        Console.WriteLine($"Result: {result2.UnwrapOr(0)}");
    }
    else
    {
        Console.WriteLine("Error: Cannot divide by zero");
    }
}</code></pre>
            <p>Output: <code>Error: Cannot divide by zero</code></p>
        </section>



            <!-- Slide 7: Why FP in OOP World -->
            <section>
                <h2>FP in an OOP World</h2>
                <ul>
                    <li>Use FP for **utilities** (e.g., data transformations).</li>
                    <li>Mix both worlds: It's like peanut butter and chocolate! ü•úüç´</li>
                    <li>Examples: React (FP) in a Class-based App (OOP).</li>
                </ul>
            </section>
            <!-- Slide 8: Practical Benefits -->
            <section>
                <h2>Why Should You Care?</h2>
                <ul>
                    <li>Write fewer bugs = fewer calls at midnight üìûüí§.</li>
                    <li>Easier testing: Pure functions don‚Äôt lie. üïµÔ∏è‚Äç‚ôÇÔ∏è</li>
                    <li>Concurrency: No shared state = no headaches. üß†</li>
                </ul>
                <p>Bonus: You‚Äôll sound smart in meetings! üòé</p>
            </section>
            <!-- Slide 9: Closing & Resources -->
            <section>
                <h2>FP + OOP = Best Friends Forever</h2>
                <p>Functional Programming isn‚Äôt here to replace OOP. It‚Äôs here to make it better!</p>
                <p>Want to learn more? Check out:</p>
                <ul>
                    <li>Eloquent JavaScript (Ch. 6)</li>
                    <li>Functional Programming in Elm</li>
                    <li>Haskell for Great Justice! (Just kidding üòÑ)</li>
                </ul>
                <h3>Thank you! Q&A time! üßê</h3>
            </section>
            <section>
                <h2>
                    Exit(0)
                </h2>
            </section>
        </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            hash: true,

            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
        });
    </script>
</body>

</html>
