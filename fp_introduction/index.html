<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Functional 101</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/moon.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<style>
    .fragment.blur {
        filter: blur(5px);
    }

    .fragment.blur.visible {
        filter: none;
    }
</style>

<body>
    <div class="reveal">
        <div class="slides">
            <!-- Slide 1: Title -->
            <section>
                <h1>Functional 101</h1>
                <h3>"More Than Just Functions"</h3>
            </section>

            <section>
                <h2>Disclaimer</h2>
                <p>This presentation is your friendly introduction to the basic mindset of Functional Programming (FP). üå±</p>
                <p>We‚Äôre keeping it light, fun, and simple‚Äîno deep dives (yet). üòÑ</p>
                <p>So, sit back, relax, and let‚Äôs get those FP vibes started! üßò‚Äç‚ôÇÔ∏è</p>
            </section>

            <section>
                <h3>Hi OO!!</h3>
                <img width="900" src="image/oo_fp_meme_ns.jpg" />
            </section>

            <section style="text-align: Left;">
                <h3>
                    Programing Paradigm
                </h3>

                <p class="fragment custom blur" style="color:red">Imperative - Procedural, OOP</p>
                <p class="fragment custom blur" style="color:green">Declarative - Functional, Reactive, Logic</p>
                <p class="fragment custom blur" style="color:gray">Concurrent - Acto</p>
                <p class="fragment custom blur" style="color:gray">Meta - Template, Reflective</p>
                <p class="fragment custom blur" style="color:gray">...</p>
            </section>

        <section>
         <h2>The Awesome Family of Functional Languages</h2>
          <p>
            <strong>ML üß†:</strong> Static typing ‚Äì It knows your types before you do! üîí
          </p>
          <p>
            <strong>Lisp üçï:</strong> Dynamic typing ‚Äì It figures it out as it goes! üîÑ
          </p>
        </section>

            <section>
                <img src="image/fp_lang_list.png"
                    alt="fp lang list" style="width: 1200px; margin-bottom: 20px;" />
            </section>

      <section>
        <h2>Functional Programming Perspective</h2>
        <p>
          Functional programming provides a different perspective on programming than what you have experienced so far.
          Adapting to that perspective requires letting go of old ideas: assignment statements, loops, classes and objects, among others.
          That won‚Äôt be easy.
        </p>
      </section>

        <section>
          <img width="200" src="https://sanette.github.io/ocaml2.org/img/OCaml_Sticker.svg" />
          <h2>
            "A language that doesn't affect the way you think about programming is not worth knowing."
          </h2>
        </section>

      <section>
        <h2>üöß OOP with Mutable List (C#)</h2>
        <pre><code class="language-csharp" data-trim data-noescape>
        var numbers = new List&lt;int&gt { 1, 2, 3, 4 };

        numbers.Add(5);

        Console.WriteLine("Numbers: " + string.Join(", ", numbers));
        </code></pre>
        <p>üõë List is mutable. Data can change freely.</p>
        <p>Output: <code>Numbers: 1, 2, 3, 4, 5</code></p>
      </section>

      <section>
        <h2>‚ú® FP with Immutable List (OCaml)</h2>
        <pre><code class="language-ocaml" data-trim data-noescape>
let numbers = [1; 2; 3; 4];;

let updated_numbers = numbers @ [5];;

List.iter (fun x -> Printf.printf "%d " x) updated_numbers;;
        </code></pre>
        <p>üöÄ Lists are immutable. You create a new list instead.</p>
        <p>Output: <code>1 2 3 4 5</code></p>
      </section>


<section>
          <h2>What is Currying?</h2>
          <p>
            In OCaml, currying is the process of transforming a function that takes multiple arguments
            into a series of functions that each take a single argument.
          </p>
          <pre><code>let add x y = x + y</code></pre>
          <p><strong>Curried Function:</strong></p>
          <pre><code>let add x = fun y -> x + y</code></pre>
          <h4>Code Example:</h4>
          <pre><code data-trim data-noescape>
let add x = fun y -> x + y
let add2 = add 2
let result = add2 3  (* result = 5 *)
          </code></pre>
        </section>


<section>
          <h2>What is Partial Application?</h2>
          <p>
            Partial application is when you apply some, but not all, of the arguments to a function.
            It creates a simpler function that still needs the remaining arguments.
          </p>
          <pre><code>let add x y = x + y</code></pre>
          <pre><code>let add5 = add 5</code></pre>
          <h4>Code Example:</h4>
          <pre><code data-trim data-noescape>
let add x y = x + y
let add5 = add 5
let result = add5 3  (* result = 8 *)
          </code></pre>
        </section>


<section>
  <h2>What is Function Composition?</h2>
  <p>
    Function composition is like making a new function by combining two functions, where the output of one function
    becomes the input of the other.
  </p>
  <pre><code data-trim data-noescape>
let add2 x = x + 2
let multiply3 x = x * 3
  </code></pre>
  <h4>Composing them:</h4>
  <pre><code data-trim data-noescape>
let compose f g x = f (g x)
let f = compose add2 multiply3
  </code></pre>
</section>

<section>
  <h4>Code Example:</h4>
  <pre><code data-trim data-noescape>
let add2 x = x + 2
let multiply3 x = x * 3
let compose f g x = f (g x)
let f = compose add2 multiply3
let result = f 4  (* result = 14 *)
(*
    let f x = x
            |&gt  multiply3
            |&gt add2;;
                        *)
(* f 4;; *)
  </code></pre>
  <h4>How it works:</h4>
  <ul>
    <li><code>multiply3 4 = 12</code></li>
    <li><code>add2 12 = 14</code></li>
  </ul>
  <h4>Final Result:</h4>
  <p><code>f(4) = 14</code></p>
</section>

 <section>
        <h2>Lazy Evaluation in Haskell</h2>
        <pre><code>nums = [1..]

main = print (take 5 nums)</code></pre>
        <p>Output: <code>[1, 2, 3, 4, 5]</code></p>
      </section>

            <section>
                <h2>Algebraic Data Type (ADT) in OCaml</h2>
                <pre><code class="language-ocaml" data-trim data-noescape>
type shape =
  | Circle of float
  | Rectangle of float * float
  | Triangle of { base : float; height : float }

let area s =
  match s with
  | Circle r -> 3.14159 *. r *. r
  | Rectangle (w, h) -> w *. h
  | Triangle t -> 0.5 *. t.base *. t.height

let () =
  let circle = Circle 5.0 in
  let rectangle = Rectangle (4.0, 6.0) in
  let triangle = Triangle { base = 8.0; height = 5.0 } in

  Printf.printf "The area of the circle is: %.2f\n" (area circle);
  Printf.printf "The area of the rectangle is: %.2f\n" (area rectangle);
  Printf.printf "The area of the triangle is: %.2f\n" (area triangle)
                </code></pre>
            </section>


            <!-- Slide 6: Code Example -->
            <section>
                <h1>OOP vs FP</h1>
                <p>Let‚Äôs compare Object-Oriented Programming and Functional Programming.</p>
            </section>

            <section>
                <h2>Object-Oriented Programming</h2>
                <pre><code class="language-csharp" data-trim data-noescape>
class Chef
{
    public string MakePizza(string toppings)
    {
        return $"Pizza with {toppings}";
    }
}

class Program
{
    static void Main(string[] args)
    {
        Chef chef = new Chef();
        Console.WriteLine(chef.MakePizza("cheese"));
    }
}
                </code></pre>
            </section>

            <!-- Slide 3: FP -->
            <section>
                <h2>Functional Programming</h2>
                <pre><code class="language-ocaml" data-trim data-noescape>
let make_pizza toppings =
  "Pizza with " ^ toppings

let () =
  print_endline (make_pizza "cheese")
                </code></pre>
            </section>

            <section>
                <h1>Monad in OCaml vs Error Handling in C#</h1>
                <p>Two approaches to handling errors and computation contexts effectively.</p>
            </section>

            <section>
                <img src="https://miro.medium.com/v2/resize:fit:4800/format:webp/1*HiqeaDuQxlpANkfPJieuVA.jpeg"
                    alt="Monad meme" style="width: 650px; margin-bottom: 20px;" />
            </section>

            <section>
                <img src="http://www.quickmeme.com/img/44/44b0bd758f8ee5c81362923f0d5c8e017c9ddf623925e60c29a4c015b89fbb45.jpg"
                    alt="Monad meme" style="width: 800px; margin-bottom: 20px;" />
            </section>

            <section>
                <img src="https://www.rms.com/sites/default/files/inline-images/Converted_0.jpg"
                    alt="schrodingers cat in side the box" style="width: 800px; margin-bottom: 20px;" />
            </section>

<section>
    <h3>A polymorphic type that's basically Schr√∂dinger's Cat Box</h3>
    <pre><code class="language-ocaml" data-trim data-noescape>
(* Meet the 'a option type, now with cats! *)
type 'a option =
  | None  (* "No cat in the box üòø" *)
  | Some of 'a (* "There's a cat in the box! üò∫" *)

(* The 'a option is like a mysterious cat box.
   You never know if it's empty or if there's a cat inside until you check! *)

(* Example *)
Some "Whiskers";;  (* "Congrats, you found Whiskers in the box!" *)
- : string option = Some "Whiskers"

None;;             (* "Uh-oh, the box is empty. No cat today." *)
- : 'a option = None
    </code></pre>
</section>

            <!-- Slide 2: Monad in OCaml -->
            <section>
                <h2>Monad in OCaml</h2>
                <p>Monads in OCaml encapsulate computations with context, such as handling errors without exceptions.</p>
                <pre><code class="language-ocaml" data-trim data-noescape>
(* Safe division using Option Monad *)
let safe_divide x y =
  if y = 0 then None else Some (x / y)

(* Monad bind function *)
let bind opt f =
  match opt with
  | None -> None
  | Some value -> f value

let () =
  let result = bind (safe_divide 10 2) (fun x ->
                safe_divide x 0) in
  match result with
  | None -> print_endline "Error: Division by zero!"
  | Some value -> print_endline (string_of_int value)
(* Output: Error: Division by zero! *)
                </code></pre>
            </section>

         <section>
            <h2>Error Handling in C#</h2>
            <p>Using <strong>Option&lt;T&gt;</strong> type to handle errors without exceptions.</p>
        </section>

        <section>
            <h2>Problem with Exceptions</h2>
            <p>Using exceptions for control flow:</p>
            <pre><code class="language-csharp" data-trim data-noescape>using System;

class Program
{
    static double SafeDivide(double x, double y)
    {
        if (y == 0)
            throw new DivideByZeroException("Cannot divide by zero");
        return x / y;
    }

    static void Main()
    {
        try
        {
            double result = SafeDivide(10, 2);
            result = SafeDivide(result, 0); // Throws exception
            Console.WriteLine(result);
        }
        catch (DivideByZeroException e)
        {
            Console.WriteLine($"Error: {e.Message}");
        }
    }
}</code></pre>
            <p><strong>Issues:</strong> Exception handling interrupts flow, and testing is harder.</p>
        </section>

        <section>
            <h2>Implement Option&lt;T&gt; in C#</h2>
<pre><code data-trim data-noescape>
public class Option&lt;T&gt;
{
    private readonly T _value;
    public bool IsSome { get; }
    public bool IsNone => !IsSome;

    private Option(T value, bool isSome)
    {
        _value = value;
        IsSome = isSome;
    }

    public static Option&lt;T&gt; Some(T value)
    {
        if (value == null)
            throw new ArgumentNullException(nameof(value), "Cannot create an Option.Some with a null value.");
        return new Option&lt;T&gt;(value, true);
    }

    public static Option&lt;T&gt; None() => new Option&lt;T&gt;(default, false);

    public Option&lt;TResult&gt; Bind&lt;TResult&gt;(Func&lt;T, Option&lt;TResult&gt;&gt; binder)
    {
        if (binder == null)
            throw new ArgumentNullException(nameof(binder));
        return IsSome ? binder(_value) : Option&lt;TResult&gt;.None();
    }

    public T UnwrapOr(T defaultValue) => IsSome ? _value : defaultValue;

    public override string ToString() => IsSome ? $"Some({_value})" : "None";
}
</code></pre>
        </section>

        <section>
            <h2>Safe Division with Option&lt;T&gt;</h2>
            <pre><code class="csharp" data-trim data-noescape>
public class Program
{
    public static Option&lt;int&gt; SafeDivide(int x, int y)
    {
        return y == 0 ? Option&lt;int&gt;.None() : Option&lt;int&gt;.Some(x / y);
    }

    public static void Main()
    {
        var result = SafeDivide(10, 2).Bind(x => SafeDivide(x, 0));

        if (result.IsNone)
        {
            Console.WriteLine("Error: Division by zero!");
        }
        else
        {
            Console.WriteLine($"Result: {result.UnwrapOr(0)}");
        }
    }
}
</code></pre>
            <p><code>Error: Cannot divide by zero</code></p>
        </section>

        <section>
            <h2>Is Same ?</h2>
            <pre><code class="csharp" data-trim data-noescape>
class Program
{
    static double? SafeDivide(double x, double y)
    {
        if (y == 0)
            return null;
        return x / y;
    }

    static void Main()
    {
        double? result = SafeDivide(10, 2);
        if (result.HasValue)
        {
            result = SafeDivide(result.Value, 0); // Attempt to divide
        }

        if (result.HasValue)
        {
            Console.WriteLine($"Result: {result.Value}");
        }
        else
        {
            Console.WriteLine("Error: Division by zero!");
        }
    }
}
</code></pre>
            <p><code>Nullable in C#</code></p>
        </section>

            <!-- Slide 8: Practical Benefits -->
            <section>
                <h2>Why Should You Care?</h2>
                <ul>
                    <li>Write fewer bugs = fewer calls at midnight üìûüí§.</li>
                    <li>Easier testing: Pure functions don‚Äôt lie. üïµÔ∏è‚Äç‚ôÇÔ∏è</li>
                    <li>Concurrency: No shared state = no headaches. üß†</li>
                </ul>
            </section>
            <!-- Slide 9: Closing & Resources -->
            <section>
                <h2>FP + OOP = Best Friends Forever</h2>
                <p>Functional Programming isn‚Äôt here to replace OOP. It‚Äôs here to make it better!</p>
                <p>Want to learn more? Check out:</p>
                <ul>
                    <li>Eloquent JavaScript (Ch. 6)</li>
                    <li>Functional Programming in Elm</li>
                    <li>Haskell for Great Justice! (Just kidding üòÑ)</li>
                </ul>
                <h3>Thank you! Q&A time! üßê</h3>
            </section>
            <section>
                <h2>
                    Exit(0)
                </h2>
            </section>
        </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            hash: true,

            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
        });
    </script>
</body>

</html>
